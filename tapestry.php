<?php

/**
 * Plugin Name: Tapestry
 * Plugin URI: https://www.tapestry-tool.com
 * Description: Custom post type - Tapestry
 * Version: 2.54.0-beta
 * Author: Tapestry Team, University of British Coloumbia.
 */

// Used to force-refresh assets and run updates
$TAPESTRY_VERSION_NUMBER = '2.54.0-beta';

define(
    'LOAD_KALTURA',
    (defined('KALTURA_ADMIN_SECRET') && !empty(KALTURA_ADMIN_SECRET)) &&
    (defined('KALTURA_PARTNER_ID') && !empty(KALTURA_PARTNER_ID)) &&
    (defined('KALTURA_SERVICE_URL') && !empty(KALTURA_SERVICE_URL)) &&
    (defined('KALTURA_UNIQUE_CONFIG') && !empty(KALTURA_UNIQUE_CONFIG)) &&
    file_exists(plugin_dir_path(__FILE__) . 'vendor/autoload.php')
);

error_reporting(E_ERROR | E_PARSE);

/**
 * Register endpoints.
 */
require_once dirname(__FILE__).'/classes/class.tapestry-analytics.php';
require_once dirname(__FILE__).'/classes/class.kaltura-api.php';
require_once dirname(__FILE__).'/classes/class.constants.php';
require_once dirname(__FILE__).'/endpoints.php';
require_once dirname(__FILE__).'/settings.php';
require_once dirname(__FILE__).'/plugin-updates.php';

use Kaltura\Client\Enum\FlavorAssetStatus;

/**
 * Register Tapestry type on initialization.
 */
function create_tapestry_type()
{
    $labels = [
        'name' => __('Tapestries'),
        'singular_name' => __('Tapestry'),
        'all_items' => __('All Tapestries'),
    ];
    $args = [
        'label' => __('tapestry'),
        'labels' => $labels,
        'description' => '',
        'public' => true,
        'publicly_queryable' => true,
        'show_ui' => true,
        'delete_with_user' => false,
        'show_in_rest' => true,
        'rest_base' => '',
        'rest_controller_class' => 'WP_REST_Posts_Controller',
        'has_archive' => false,
        'show_in_menu' => true,
        'show_in_nav_menus' => true,
        'exclude_from_search' => false,
        'capability_type' => 'post',
        'map_meta_cap' => true,
        'hierarchical' => false,
        'rewrite' => ['with_front' => true],
        'query_var' => true,
        'supports' => ['title', 'editor', 'thumbnail', 'author'],
    ];
    register_post_type('tapestry', $args);
}
add_action('init', 'create_tapestry_type');

/**
 * Register Tapestry Node type on initialization.
 */
function create_tapestry_node_type()
{
    $labels = [
        'name' => __('Tapestry Nodes'),
        'singular_name' => __('Tapestry Node'),
        'all_items' => __('Tapestry Nodes'),
    ];
    $args = [
        'label' => __('tapestry-node'),
        'labels' => $labels,
        'description' => '',
        'public' => true,
        'publicly_queryable' => true,
        'show_ui' => true,
        'delete_with_user' => false,
        'show_in_rest' => true,
        'rest_base' => '',
        'rest_controller_class' => 'WP_REST_Posts_Controller',
        'has_archive' => false,
        'show_in_menu' => false,
        'show_in_nav_menus' => false,
        'exclude_from_search' => false,
        'capability_type' => 'post',
        'map_meta_cap' => true,
        'hierarchical' => false,
        'rewrite' => ['with_front' => true],
        'query_var' => true,
        'supports' => ['title', 'editor', 'thumbnail', 'author'],
    ];
    register_post_type('tapestry_node', $args);
}
add_action('init', 'create_tapestry_node_type');

/**
 * Show posts of Tapestry type on the home page.
 */
function add_tapestry_post_types_to_query($query)
{
    if (is_home() && $query->is_main_query()) {
        $query->set('post_type', ['post', 'tapestry', 'tapestry-node']);
    }

    return $query;
}
add_action('pre_get_posts', 'add_tapestry_post_types_to_query');

/*
 * Add custom tapestry_thumb size
 */
add_action('after_setup_theme', 'tapestry_theme_setup');
function tapestry_theme_setup()
{
    add_image_size('tapestry_thumb', 420, 420, true);
}

/*
 * Enqueue scripts and styles for the tapestry
 */

add_action('wp_enqueue_scripts', 'tapestry_enqueue_libraries');
add_action('wp_enqueue_scripts', 'tapestry_enqueue_vue_app');
add_filter('style_loader_tag', 'tapestry_add_style_attributes', 10, 2);

function tapestry_enqueue_vue_app()
{
    global $post;
    if ('tapestry' == get_post_type($post) && !post_password_required($post)) {
        global $TAPESTRY_VERSION_NUMBER;

        $use_dev = (defined('TAPESTRY_USE_DEV_MODE') && !empty(TAPESTRY_USE_DEV_MODE)) || isset($_GET['debug']);

        // register the Vue build script.
        $vueUrl = $use_dev ? 'http://localhost:8080/dist' : plugin_dir_url(__FILE__).'templates/vue/dist';

        wp_register_script( // the app build script generated by Webpack.
            'tapestry_d3_vue',
            $vueUrl.'/build.js?v='.$TAPESTRY_VERSION_NUMBER,
            [],
            null,
            true
        );

        // make custom data available to the Vue app with wp_localize_script.
        global $post;
        global $wp_roles;

        $kaltura_partner_id = null;
        $kaltura_unique_configuration = null;
        if (LOAD_KALTURA) {
            $kaltura_partner_id = KALTURA_PARTNER_ID;
            $kaltura_unique_configuration = KALTURA_UNIQUE_CONFIG;
        }
        
        $currentUser = wp_get_current_user();
        $currentUser->data = (object) [
            'ID' => $currentUser->data->ID,
            'user_nicename'=> $currentUser->data->user_nicename,
            'user_email'=> $currentUser->data->user_email,
            'display_name'=> $currentUser->data->display_name
        ];

        wp_localize_script(
            'tapestry_d3_vue', // vue script handle defined in wp_register_script.
            'wpData', // javascript object that will made availabe to Vue.
            [ // wordpress data to be made available to the Vue app in 'wpData'
                'directory_uri' => plugin_dir_url(__FILE__).'templates/vue/dist', // child theme directory path.
                'vue_uri' => $vueUrl, // path to vue
                'rest_url' => untrailingslashit(esc_url_raw(rest_url())), // URL to the REST endpoint.
                'wpUrl' => get_bloginfo('url'),
                'logoutUrl' => wp_logout_url(get_permalink()),
                'app_path' => $post->post_name, // page where the custom page template is loaded.
                'post_categories' => get_terms([
                    'taxonomy' => 'category', // default post categories.
                    'hide_empty' => true,
                    'fields' => 'names',
                ]),
                'nonce' => wp_create_nonce('wp_rest'),
                'wpUserId' => apply_filters('determine_current_user', false),
                'adminAjaxUrl' => admin_url('admin-ajax.php'),
                'file_upload_nonce' => wp_create_nonce('media-form'),
                'upload_url' => admin_url('async-upload.php'),
                'roles' => $wp_roles->get_names(),
                'wpCanEditTapestry' => current_user_can('edit_post', get_the_ID()),
                'currentUser' => $currentUser,
                'uploadDirArray' => wp_upload_dir(),
                'kaltura' => array(
                    'kalturaStatus' => LOAD_KALTURA,
                    "partnerId" => $kaltura_partner_id,
                    "uniqueConfiguration" => $kaltura_unique_configuration,
                ),
            ]
        );

        // enqueue the Vue app script with localized data.
        wp_enqueue_script('tapestry_d3_vue');
    }
}

function tapestry_enqueue_libraries()
{
    global $post;
    global $TAPESTRY_VERSION_NUMBER;
    if ('tapestry' == get_post_type($post) && !post_password_required($post)) {
        $LIBS_FOLDER_URL = plugin_dir_url(__FILE__).'templates/libs/';

        // CSS
        wp_enqueue_style('font-awesome-5', 'https://use.fontawesome.com/releases/v5.5.0/css/all.css', [], null);
        wp_enqueue_style('tapestry-css', plugin_dir_url(__FILE__).'templates/tapestry.css', [], $TAPESTRY_VERSION_NUMBER);

        // JS
        wp_enqueue_script('heartbeat');
        wp_enqueue_script('es2015-test', $LIBS_FOLDER_URL.'es2015-test.js');
    }
}

function tapestry_add_style_attributes($html, $handle)
{
    global $post;
    if ('tapestry' == get_post_type($post) && !post_password_required($post)) {
        if ('font-awesome-5' === $handle) {
            return str_replace("media='all'", "media='all' integrity='sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU' crossorigin='anonymous'", $html);
        }
    }

    return $html;
}

/**
 * Filter the template for Tapestry post.
 */
function load_tapestry_template($singleTemplate)
{
    global $post;
    if ('tapestry' === $post->post_type) {
        $singleTemplate = dirname(__FILE__).'/templates/single-tapestry.php';
    }

    return $singleTemplate;
}
add_filter('single_template', 'load_tapestry_template');

function create_new_tapestry()
{
    if (!current_user_can('edit_posts')) {
        return "";
    }

    $prefix = get_rest_url(null, 'tapestry-tool/v1');

    return "
        <button onclick='promptAddNewTapestry()'>
            Add Tapestry
        </button>
        <script type='text/javascript'>
            function promptAddNewTapestry() {
                let name = prompt(`Enter a name`);
                if (name !== null) {
                    var apiUrl = '{$prefix}';
                    let payload = {};
                    payload[`nodes`] = [];
                    payload[`groups`] = [];
                    payload[`links`] = [];
                    payload[`title`] = name;
                    return new Promise((fulfill, reject) => {
                        let xhr = new XMLHttpRequest();
                        xhr.open('POST', apiUrl + '/tapestries');
                        xhr.setRequestHeader(`Content-Type`, `application/json;charset=UTF-8`);
                        xhr.setRequestHeader(`X-WP-Nonce`, `".wp_create_nonce('wp_rest')."`);
                        xhr.onload = () => {
                            if (xhr.status >= 200 && xhr.status < 300) {
                                fulfill(xhr.response);
                            } else {
                                reject({
                                    status: xhr.status,
                                    statusText: xhr.statusText
                                });
                            }
                        };
                        xhr.onerror = () => {
                            reject({
                                status: xhr.status,
                                statusText: xhr.statusText
                            });
                        };
                        xhr.send(JSON.stringify(payload));
                    }).then(data => {
                        let res = JSON.parse(data);
                        window.location.href = res.settings.permalink;
                    }).catch(err => {
                        console.log(err);
                        alert(`Error occured while creating tapestry, please try again`);
                    })
                }
            }
        </script>
    ";
}

add_shortcode('new_tapestry_button', 'create_new_tapestry');

function replace_special_apostrophe($str)
{
    return str_replace('’', "'", $str);
}

$quote_style = 'ENT_QUOTES';
add_filter('rest_prepare_post', 'prefix_title_entity_decode');
function prefix_title_entity_decode($response)
{
    $data = $response->get_data();
    $data['title']['rendered'] = wp_specialchars_decode(html_entity_decode($data['title']['rendered']), $quote_style);
    $data['title']['rendered'] = replace_special_apostrophe($data['title']['rendered']);
    $data['content']['rendered'] = wp_specialchars_decode(html_entity_decode($data['content']['rendered']), $quote_style);
    $data['content']['rendered'] = replace_special_apostrophe($data['content']['rendered']);
    $response->set_data($data);

    return $response;
}

// Analytics

register_activation_hook(__FILE__, 'create_tapestry_analytics_schema');
function create_tapestry_analytics_schema()
{
    $analytics = new TapestryAnalytics();
    $analytics->createSchema();
}

add_action('wp_ajax_nopriv_tapestry_tool_log_event', 'tapestry_tool_log_event');
add_action('wp_ajax_tapestry_tool_log_event', 'tapestry_tool_log_event');
function tapestry_tool_log_event()
{
    $analytics = new TapestryAnalytics();
    $analytics->log($_POST);

    wp_die();
}


// Kaltura

add_action('upload_videos_to_kaltura', 'upload_videos_to_kaltura');

/**
 * Uploads given videos from local server to Kaltura.
 * Does nothing if an upload is already in progress.
 * 
 * @param object $upload_request    HTTP request body
 */
function upload_videos_to_kaltura($upload_request)
{
    if (!is_object($upload_request) || !isset($upload_request->videos) || !isset($upload_request->useKalturaPlayer)) {
        return;
    }

    $videos = $upload_request->videos;
    $use_kaltura_player = $upload_request->useKalturaPlayer;

    if (LOAD_KALTURA) {
        $is_upload_in_progress = get_option(KalturaUpload::IN_PROGRESS_OPTION);

        if ($is_upload_in_progress === false) {
            // False return value means option does not exist in database yet
            add_option(KalturaUpload::IN_PROGRESS_OPTION, KalturaUpload::NO_VALUE);
        } elseif ($is_upload_in_progress !== KalturaUpload::NO_VALUE) {
            return;
        }

        update_option(KalturaUpload::IN_PROGRESS_OPTION, KalturaUpload::YES_VALUE);
        update_option(KalturaUpload::STOP_UPLOAD_OPTION, KalturaUpload::NO_VALUE, false);

        try {
            perform_batched_upload_to_kaltura($videos, $use_kaltura_player);
        } catch (Exception $e) {
            error_log($e->getMessage());
        } finally {
            update_option(KalturaUpload::IN_PROGRESS_OPTION, KalturaUpload::NO_VALUE);
            update_option(KalturaUpload::STOP_UPLOAD_OPTION, KalturaUpload::NO_VALUE, false);
        }
    }
}

/**
 * Uploads videos to Kaltura.
 *
 * Video files are transferred up to UPLOAD_BATCH_SIZE at a time.
 * At the end of each batch, waits synchronously for all videos in the batch to finish converting (or error),
 * before uploading the next batch.
 *
 * @param array $videos     List of video nodes to upload. These should be objects with the following interface:
 *                          [
 *                              [tapestryID] => 123,
 *                              [nodeID] => 123,
 *                          ]
 *                          Nodes are checked to be videos and to be local Wordpress uploads before being uploaded to Kaltura.
 * @param bool $use_kaltura_player   Whether to switch uploaded videos to use the Kaltura media player.
 *
 * @return int The number of videos that were successfully uploaded.
 */
function perform_batched_upload_to_kaltura($videos, $use_kaltura_player)
{
    $current_date = date('Y/m/d');

    $videos_to_upload = create_upload_log($videos);
    update_upload_log($videos_to_upload);

    $kalturaApi = new KalturaApi();

    $num_successfully_uploaded = 0;
    $batch_start = 0;

    for ($batch_start; $batch_start < count($videos_to_upload); $batch_start += KalturaUpload::UPLOAD_BATCH_SIZE) {
        // Retrieve fresh value without caching, since we expect the option value to change underneath
        $GLOBALS['wp_object_cache']->delete(KalturaUpload::STOP_UPLOAD_OPTION, 'options');
        $stop_requested = get_option(KalturaUpload::STOP_UPLOAD_OPTION);
        if ($stop_requested === KalturaUpload::YES_VALUE) {
            break;
        }

        $batch = array_slice($videos_to_upload, $batch_start, KalturaUpload::UPLOAD_BATCH_SIZE);

        foreach ($batch as $video) {
            $video->uploadStatus = UploadStatus::UPLOADING;
            update_upload_log($videos_to_upload);

            $kaltura_data = null;
            try {
                $kaltura_data = $kalturaApi->uploadKalturaVideo($video->file, $current_date);
            } catch (Exception $e) {
                $error_start = "Unable to upload video '".$video->file->name."' to Kaltura due to: \n";

                error_log($error_start.$e);

                $video->uploadStatus = UploadStatus::ERROR;
                $video->additionalInfo = $error_start.$e->getMessage();
                update_upload_log($videos_to_upload);
                continue;
            }

            $video->kalturaID = $kaltura_data->id;
            $video->uploadStatus = UploadStatus::CONVERTING;
            update_upload_log($videos_to_upload);
        }

        // Filter out videos that did not successfully upload so we don't get an infinite loop
        $remaining_videos = array_filter($batch, function($vid) {
            return $vid->uploadStatus ===  UploadStatus::CONVERTING;
        });

        while (count($remaining_videos) > 0) {
            sleep(5);
            $videos_to_remove = array();

            foreach ($remaining_videos as $video) {
                $response = $kalturaApi->getVideoUploadStatus($video->kalturaID);

                if ($response->status == FlavorAssetStatus::READY) {
                    save_and_delete_local_video($video, $response, $use_kaltura_player);

                    $video->uploadStatus = UploadStatus::COMPLETE;
                    update_upload_log($videos_to_upload);

                    array_push($videos_to_remove, $video);

                    $num_successfully_uploaded++;
                } elseif ($response->status == FlavorAssetStatus::ERROR) {
                    $video->uploadStatus = UploadStatus::ERROR;
                    $video->additionalInfo = 'An error occurred. Could not convert the video.';
                    update_upload_log($videos_to_upload);

                    array_push($videos_to_remove, $video);
                }
            }

            $remaining_videos = array_udiff($remaining_videos, $videos_to_remove, function ($video1, $video2) {
                if ($video1->tapestryID > $video2->tapestryID) {
                    return 1;
                } elseif ($video1->tapestryID < $video2->tapestryID) {
                    return -1;
                } else {
                    return $video1->nodeID - $video2->nodeID;
                }
            });
        }
    }

    // Mark remaining videos as canceled, if any
    for ($i = $batch_start; $i < count($videos_to_upload); $i++) {
        $videos_to_upload[$i]->uploadStatus = UploadStatus::CANCELED;
    }
    update_upload_log($videos_to_upload);

    return $num_successfully_uploaded;
}

/**
 * Initializes the list of videos to upload.
 * Silently excludes provided videos that are not suitable for upload.
 */
function create_upload_log($videos)
{
    $upload_folder = wp_upload_dir()['path'];

    $upload_log = array();

    foreach ($videos as $video) {
        if (!is_object($video) || !isset($video->tapestryID) || !isset($video->nodeID)) {
            continue;
        }

        $node = new TapestryNode($video->tapestryID, $video->nodeID);
        if (TapestryHelpers::videoCanBeUploaded($node)) {
            $file_name = pathinfo($node->getTypeData()->mediaURL)['basename'];
            $file_obj = new StdClass();
            $file_obj->file_path = $upload_folder."/".$file_name;
            $file_obj->name = $file_name;

            $video_info = (object) [
                'tapestryID' => $video->tapestryID,
                'nodeID' => $video->nodeID,
                'nodeTitle' => $node->getTitle(),
                'uploadStatus' => UploadStatus::NOT_STARTED,
                'file' => $file_obj,
                'kalturaID' => '',
                'additionalInfo' => '',
            ];
            array_push($upload_log, $video_info);
        }
    }

    return $upload_log;
}

function save_and_delete_local_video($video, $response_data, $use_kaltura_player)
{
    $node = new TapestryNode($video->tapestryID, $video->nodeID);

    $typeData = $node->getTypeData();
    $typeData->mediaURL = $response_data->dataUrl."?.mp4";
    $typeData->kalturaData = array(
                    "id" => $response_data->id,
                    "partnerId" => $response_data->partnerId,
                );
    
    if ($use_kaltura_player) {
        $typeData->kalturaId = $response_data->id;
        $node->set((object) ['mediaFormat' => "kaltura"]);
    }

    $node->set($typeData);
    $node->save();

    wp_delete_file($video->file->file_path);
}

function update_upload_log($videos)
{
    // Filter the upload log objects so that certain information (e.g. the file path of the videos) is not returned
    $filtered_upload_log = array_map(function ($video) {
        return (object) [
            'tapestryID' => $video->tapestryID,
            'nodeID' => $video->nodeID,
            'nodeTitle' => $video->nodeTitle,
            'uploadStatus' => $video->uploadStatus,
            'kalturaID' => $video->kalturaID,
            'additionalInfo' => $video->additionalInfo,
        ];
    }, $videos);

    // This will create the option if it doesn't exist
    update_option(KalturaUpload::UPLOAD_LOG_OPTION, $filtered_upload_log);
}
